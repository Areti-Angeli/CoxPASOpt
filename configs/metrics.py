# -*- coding: utf-8 -*-
"""metrics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aHWamcX4Q5xENbEqvALo9hKNxKIBgZH0
"""

def R_set(x):
	'''Create an indicator matrix of risk sets, where T_j >= T_i.
	Note that the input data have been sorted in descending order.
	Input:
		x: a PyTorch tensor that the number of rows is equal to the number of samples.
	Output:
		indicator_matrix: an indicator matrix (which is a lower traiangular portions of matrix).
	'''
	n_sample = x.size(0)
	matrix_ones = torch.ones(n_sample, n_sample)
	indicator_matrix = torch.tril(matrix_ones)

	return(indicator_matrix)


def neg_par_log_likelihood(pred, ytime, yevent):
	'''Calculate the average Cox negative partial log-likelihood.
	Note that this function requires the input data have been sorted in descending order.
	Input:
		pred: linear predictors from trained model.
		ytime: true survival time from load_data().
		yevent: true censoring status from load_data().
	Output:
		cost: the cost that is to be minimized.
	'''
	n_observed = yevent.sum(0)
	ytime_indicator = R_set(ytime)
	###if gpu is being used
	if torch.cuda.is_available():
		ytime_indicator = ytime_indicator.cuda()
	###
	risk_set_sum = ytime_indicator.mm(torch.exp(pred))
	diff = pred - torch.log(risk_set_sum)
	sum_diff_in_observed = torch.transpose(diff, 0, 1).mm(yevent)
	cost = (- (sum_diff_in_observed / n_observed)).reshape((-1,))

	return(cost)


def c_index(pred, ytime, yevent):
    '''Calculate concordance index to evaluate the performance of survival prediction.
    Input:
        pred: linear predictor for the Cox model.
        ytime: survival time
        yevent: censoring status (1: event; 0: censor)
    Output:
        c_index: the concordance index calculated based on Harrell's definition.
    '''
    n_sample = len(ytime)
    pred_matrix = np.zeros((n_sample, n_sample))
    time_matrix = np.zeros((n_sample, n_sample))
    event_matrix = np.zeros((n_sample, n_sample))

    for i in range(n_sample):
        for j in range(n_sample):
            time_matrix[i, j] = ytime[j] - ytime[i]
            event_matrix[i, j] = yevent[j]

    # Ensure pred is a 1D tensor and access elements directly
    pred = pred.view(-1)  # Flatten pred if necessary

    for j in range(n_sample):
        for i in range(n_sample):
            # Use .item() to get a single value from the tensor
            if pred[i].item() < pred[j].item():
                pred_matrix[j, i] = 1
            elif pred[i].item() == pred[j].item():
                pred_matrix[j, i] = 0.5

    concordant = 0
    discordant = 0
    tied_risk = 0
    comparable = 0

    for i in range(n_sample):
        for j in range(i + 1, n_sample):
            if time_matrix[i, j] > 0 and event_matrix[i, j] == 1:
                comparable += 1
                if pred_matrix[i, j] == 1:
                    concordant += 1
                elif pred_matrix[i, j] == 0:
                    discordant += 1
                else:
                    tied_risk += 1
            elif time_matrix[i, j] < 0 and event_matrix[j, i] == 1:
                comparable += 1
                if pred_matrix[j, i] == 1:
                    concordant += 1
                elif pred_matrix[j, i] == 0:
                    discordant += 1
                else:
                    tied_risk += 1

    c_index = (concordant + 0.5 * tied_risk) / comparable
    return c_index