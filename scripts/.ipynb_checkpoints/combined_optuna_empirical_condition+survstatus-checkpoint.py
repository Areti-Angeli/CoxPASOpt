# -*- coding: utf-8 -*-
"""combined_optuna_empirical_condition+survstatus.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-tEmwM5jrb7fd5airK71p6QfMk2ZVr5_
"""

import os

!pwd

import os
import pandas as pd
import pickle

df = pd.read_excel("../data/data_inputs/pt.xlsx")

df['target_label'] = df['target_label'].str.split(';')

df_n = df.explode("target_label").pivot_table(index="source_label", columns="target_label", aggfunc="size", fill_value=0).reset_index()
df_n = df_n.set_index('source_label')

df_n.to_excel("../data/data_outputs/pt_fixed.xlsx")


import shap
import numpy as np
import pandas as pd
import math
import copy
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt

import torch
import torch.nn.functional as F
import torch.nn as nn
import torch.optim as optim
import matplotlib.pyplot as plt

from sklearn.metrics import roc_auc_score, f1_score

torch.manual_seed(0)


"""### Optuna Hyperparameter search spaces"""

# Define the Optuna objective function

def objective(trial):
    # Hyperparameter search spaces
    Learning_Rate = trial.suggest_loguniform('Learning_Rate',0.001, 0.1)
    L2 = trial.suggest_loguniform('L2', 0.001, 0.01)
    Num_Epochs = trial.suggest_int('Num_Epochs', 10, 300)
    Dropout_Rate = [trial.suggest_uniform('dropout_rate_1', 0.0, 0.7), trial.suggest_uniform('dropout_rate_2', 0.0, 0.5)]
    Hidden_Nodes = 300
    Pathway_Nodes = 300
    Out_Nodes = 2

    train_x, train_ytime, train_yevent, train_age, _, _ = load_data("/../data/data_inputs/TRAINING_condition.xlsx", dtype)
    eval_x, eval_ytime, eval_yevent, eval_age, _, _ = load_data("/../data/data_inputs/VALIDATION_condition.xlsx", dtype)
    pathway_mask = load_pathway("/../data/data_outputs/pt_fixed.xlsx", dtype)

    In_Nodes = train_x.shape[1]  # Number of input nodes

# Train the model
    _, _, _, eval_cindex = trainCoxPASNet(train_x, train_age, train_ytime, train_yevent, \
        eval_x, eval_age, eval_ytime, eval_yevent, pathway_mask, \
        In_Nodes, Pathway_Nodes, Hidden_Nodes, Out_Nodes, Learning_Rate, L2, Num_Epochs, Dropout_Rate)

    # Convert eval_cindex to a Python scalar if it's not already
    eval_cindex = eval_cindex.item() if isinstance(eval_cindex, torch.Tensor) else eval_cindex

    return eval_cindex  # Return the evaluation C-index

# Main execution block
if __name__ == "__main__":
    study = optuna.create_study(direction="maximize")  # Create a study to maximize C-index
    study.optimize(objective, n_trials=100)  # Optimize for 100 trials

    # Output best results
    print("Best hyperparameters: ", study.best_params)  # Print the best hyperparameters
    print("Best C-index: ", study.best_value)  # Print the best C-index value

"""## Empirical search"""

dtype = torch.FloatTensor
''' Net Settings'''
In_Nodes = 2722 ###number of genes
Pathway_Nodes = 300 ###number of pathways
Hidden_Nodes = 300 ###number of hidden nodes
Out_Nodes = 2 ###number of hidden nodes in the last hidden layer
''' Initialize '''
Initial_Learning_Rate = [0.03, 0.01, 0.001, 0.00075]
L2_Lambda = [0.1, 0.01, 0.005, 0.001]
num_epochs = 50 ###for grid search
Num_EPOCHS = 50 ###for training
###sub-network setup
Dropout_Rate = [0.7, 0.5]
''' load data and pathway '''
pathway_mask = load_pathway("/../data/data_outputs/pt_fixed.xlsx", dtype)

x_train, ytime_train, yevent_train, age_train, feature_names_train = load_data("/../data/data_inputs/TRAINING_condition.xlsx", dtype)
x_valid, ytime_valid, yevent_valid, age_valid, feature_names_valid = load_data("/../data/data_inputs/VALIDATION_condition.xlsx", dtype)
x_test, ytime_test, yevent_test, age_test, feature_names_test = load_data("/../data/data_inputs/TEST_condition.xlsx", dtype)
opt_l2_loss = 0
opt_lr_loss = 0
opt_loss = torch.Tensor([float("Inf")])
###if gpu is being used
if torch.cuda.is_available():
	opt_loss = opt_loss.cuda()
###
opt_c_index_va = 0
opt_c_index_tr = 0
###grid search the optimal hyperparameters using train and validation data
for l2 in L2_Lambda:
	for lr in Initial_Learning_Rate:
		loss_train, loss_valid, c_index_tr, c_index_va = trainCoxPASNet(x_train, age_train, ytime_train, yevent_train, \
																x_valid, age_valid, ytime_valid, yevent_valid, pathway_mask, \
																In_Nodes, Pathway_Nodes, Hidden_Nodes, Out_Nodes, \
																lr, l2, num_epochs, Dropout_Rate)
		if loss_valid < opt_loss:
			opt_l2_loss = l2
			opt_lr_loss = lr
			opt_loss = loss_valid
			opt_c_index_tr = c_index_tr
			opt_c_index_va = c_index_va
		print ("L2: ", l2, "LR: ", lr, "Loss in Validation: ", loss_valid)



###train Cox-PASNet with optimal hyperparameters using train data, and then evaluate the trained model with test data
###Note that test data are only used to evaluate the trained Cox-PASNet
loss_train, loss_test, c_index_tr, c_index_te = trainCoxPASNet(x_train, age_train, ytime_train, yevent_train, \
							x_test, age_test, ytime_test, yevent_test, pathway_mask, \
							In_Nodes, Pathway_Nodes, Hidden_Nodes, Out_Nodes, \
							opt_lr_loss, opt_l2_loss, Num_EPOCHS, Dropout_Rate)
print("Optimal L2: ", opt_l2_loss, "Optimal LR: ", opt_lr_loss)
print("C-index in Test: ", c_index_te)



"""### Run for interpret = Actual Run for empirical"""

dtype = torch.FloatTensor

''' Net Settings'''
In_Nodes = 2722 ###number of genes
Pathway_Nodes = 300 ###number of pathways
Hidden_Nodes = 300 ###number of hidden nodes
Out_Nodes = 1 ###number of hidden nodes in the last hidden layer

''' Initialize with updated hyperparameters from empirical search '''
Initial_Learning_Rate = 0.01
L2_Lambda =  0.005
Num_EPOCHS = 1166
Dropout_Rate = [0.7, 0.5]

''' load data and pathway '''
pathway_mask = load_pathway("/../data/data_outputs/pt_fixed.xlsx", dtype)
x, ytime, yevent, age, condition, feature_names = load_data("/../data/data_inputs/entire_data_condition.xlsx", dtype)

outpath = "/../data/data_outputs/dual_cov_empirical_InterpretCoxPASNet.pt"

'''train Cox-PASNet for model interpretation'''
InterpretCoxPASNet(x, age, ytime, yevent, pathway_mask, \
					In_Nodes, Pathway_Nodes, Hidden_Nodes, Out_Nodes, \
					Initial_Learning_Rate, L2_Lambda, Num_EPOCHS, Dropout_Rate, outpath)

'''load trained Cox-PASNet'''
net = Cox_PASNet(In_Nodes, Pathway_Nodes, Hidden_Nodes, Out_Nodes, pathway_mask)
net.load_state_dict(torch.load(outpath))
###if gpu is being used
if torch.cuda.is_available():
	net.cuda()
###

'''save weights and node values into files individually'''
w_sc1 = net.sc1.weight.data.cpu().detach().numpy()
w_sc2 = net.sc2.weight.data.cpu().detach().numpy()
w_sc3 = net.sc3.weight.data.cpu().detach().numpy()
w_sc4 = net.sc4.weight.data.cpu().detach().numpy()
np.savetxt("/../data/data_outputs/dual_cov_empirical_w_sc1.csv", w_sc1, delimiter = ",")
np.savetxt("/../data/data_outputs/dual_cov_empirical_w_sc2.csv", w_sc2, delimiter = ",")
np.savetxt("/../data/data_outputs/dual_cov_empirical_w_sc3.csv", w_sc3, delimiter = ",")
np.savetxt("/../data/data_outputs/dual_cov_empirical_w_sc4.csv", w_sc4, delimiter = ",")
# Forward pass for intermediate nodes
pathway_node = net.tanh(net.sc1(x))
hidden_node = net.tanh(net.sc2(pathway_node))
hidden_2_node = net.tanh(net.sc3(hidden_node))
x_cat = torch.cat((hidden_2_node, age), 1)
lin_pred = net.sc4(x_cat)

np.savetxt("/../data/data_outputs/dual_cov_empirical_pathway_node.csv", pathway_node.cpu().detach().numpy(), delimiter = ",")
np.savetxt("/../data/data_outputs/dual_cov_empirical_hidden_node.csv", hidden_node.cpu().detach().numpy(), delimiter = ",")
np.savetxt("/../data/data_outputs/dual_cov_empirical_hidden_2_node.csv", x_cat.cpu().detach().numpy(), delimiter = ",")
np.savetxt("/../data/data_outputs/dual_cov_empirical_lin_pred.csv", lin_pred.cpu().detach().numpy(), delimiter = ",")

"""### Shap analysis empirical"""

''' SHAP Analysis for Interpretability '''

empirical_model = Cox_PASNet(In_Nodes, Pathway_Nodes, Hidden_Nodes, Out_Nodes, pathway_mask)
empirical_model.load_state_dict(torch.load("/../data/data_outputs/dual_cov_empirical_InterpretCoxPASNet.pt"))

if torch.cuda.is_available():
    empirical_model.cuda()

# Ensure dimensions match for concatenation
x_combined_empirical = torch.cat((x, condition), dim=1)

# Define a wrapper for the model
class NetWrapper(torch.nn.Module):
    def __init__(self, net):
        super(NetWrapper, self).__init__()
        self.net = net

    def forward(self, x):
        return self.net(x[:, :-1], x[:, -1])

# Wrap the trained model for SHAP
wrapped_empirical_net = NetWrapper(empirical_model)

# Perform SHAP analysis
explainer_empirical = shap.DeepExplainer(wrapped_empirical_net, x_combined_empirical)
shap_values_empirical = explainer_empirical.shap_values(x_combined_empirical)

# Update feature names to include Condition
feature_names += ['Condition']

# Generate SHAP summary plots
shap.summary_plot(shap_values_empirical, x_combined_empirical, plot_type="bar", feature_names=feature_names, max_display=50, show=False)
plt.savefig("/../data/data_outputs/empirical_dual_cov_shap_summary_bar_50.svg")

shap.summary_plot(shap_values_empirical, x_combined_empirical, plot_type="bar", feature_names=feature_names, max_display=20, show=False)
plt.savefig("/../data/data_outputs/empirical_dual_cov_shap_summary_bar_20.svg")

"""### Run for interpret = Actual Run for Optuna"""

dtype = torch.FloatTensor

''' Net Settings'''
In_Nodes = 2722 ###number of genes
Pathway_Nodes = 300 ###number of pathways
Hidden_Nodes = 300 ###number of hidden nodes
Out_Nodes = 1 ###number of hidden nodes in the last hidden layer, which is 1 and is the prognostic index for each sample

''' Initialize with updated hyperparameters from Optuna '''
Initial_Learning_Rate = 0.003471996594990395
L2_Lambda = 0.0054560355247642595
Num_EPOCHS = 1166
Dropout_Rate = [0.5395475802317309, 0.33495212131376867]

''' load data and pathway '''
pathway_mask = load_pathway("/../data/data_outputs/pt_fixed.xlsx", dtype)
x, ytime, yevent, age, condition, feature_names = load_data("/../data/data_inputs/entire_data_condition.xlsx", dtype)

outpath = "/../data/data_outputs/optuna_dual_cov_InterpretCoxPASNet.pt"

'''train Cox-PASNet for model interpretation'''
InterpretCoxPASNet(x, age, ytime, yevent, pathway_mask, \
					In_Nodes, Pathway_Nodes, Hidden_Nodes, Out_Nodes, \
					Initial_Learning_Rate, L2_Lambda, Num_EPOCHS, Dropout_Rate, outpath)

'''load trained Cox-PASNet'''
net = Cox_PASNet(In_Nodes, Pathway_Nodes, Hidden_Nodes, Out_Nodes, pathway_mask)
net.load_state_dict(torch.load(outpath))
###if gpu is being used
if torch.cuda.is_available():
	net.cuda()
###

'''save weights and node values into files individually'''
w_sc1 = net.sc1.weight.data.cpu().detach().numpy()
w_sc2 = net.sc2.weight.data.cpu().detach().numpy()
w_sc3 = net.sc3.weight.data.cpu().detach().numpy()
w_sc4 = net.sc4.weight.data.cpu().detach().numpy()
np.savetxt("/../data/data_outputs/optuna_dual_cov_w_sc1.csv", w_sc1, delimiter = ",")
np.savetxt("/../data/data_outputs/optuna_dual_cov_w_sc2.csv", w_sc2, delimiter = ",")
np.savetxt("/../data/data_outputs/optuna_dual_cov_w_sc3.csv", w_sc3, delimiter = ",")
np.savetxt("/../data/data_outputs/optuna_dual_cov_w_sc4.csv", w_sc4, delimiter = ",")
# Forward pass for intermediate nodes
pathway_node = net.tanh(net.sc1(x))
hidden_node = net.tanh(net.sc2(pathway_node))
hidden_2_node = net.tanh(net.sc3(hidden_node))
x_cat = torch.cat((hidden_2_node, age), 1)
lin_pred = net.sc4(x_cat)

np.savetxt("/../data/data_outputs/optuna_dual_cov_pathway_node.csv", pathway_node.cpu().detach().numpy(), delimiter = ",")
np.savetxt("/../data/data_outputs/optuna_dual_cov_hidden_node.csv", hidden_node.cpu().detach().numpy(), delimiter = ",")
np.savetxt("/../data/data_outputs/optuna_dual_cov_hidden_2_node.csv", x_cat.cpu().detach().numpy(), delimiter = ",")
np.savetxt("/../data/data_outputs/optuna_dual_cov_lin_pred.csv", lin_pred.cpu().detach().numpy(), delimiter = ",")

"""### Shap analysis Optuna"""

''' SHAP Analysis for Interpretability '''

optuna_model = Cox_PASNet(In_Nodes, Pathway_Nodes, Hidden_Nodes, Out_Nodes, pathway_mask)
optuna_model.load_state_dict(torch.load("/../data/data_outputs/optuna_dual_cov_InterpretCoxPASNet.pt"))

if torch.cuda.is_available():
    optuna_model.cuda()

# Ensure dimensions match for concatenation
x_combined_optuna = torch.cat((x, condition), dim=1)

# Define a wrapper for the model
class NetWrapper(torch.nn.Module):
    def __init__(self, net):
        super(NetWrapper, self).__init__()
        self.net = net

    def forward(self, x):
        return self.net(x[:, :-1], x[:, -1])

# Wrap the trained model for SHAP
wrapped_optuna_net = NetWrapper(optuna_model)

# Perform SHAP analysis
explainer_optuna = shap.DeepExplainer(wrapped_optuna_net, x_combined_optuna)
shap_values_optuna = explainer_optuna.shap_values(x_combined_optuna)

# Update feature names to include Condition
feature_names += ['Condition']

# Generate SHAP summary plots
shap.summary_plot(shap_values_optuna, x_combined_optuna, plot_type="bar", feature_names=feature_names, max_display=50, show=False)
plt.savefig("/../data/data_outputs/optuna_dual_cov_shap_summary_bar_50.svg")

shap.summary_plot(shap_values_optuna, x_combined_optuna, plot_type="bar", feature_names=feature_names, max_display=20, show=False)
plt.savefig("/../data/data_outputs/optuna_dual_cov_shap_summary_bar_20.svg")